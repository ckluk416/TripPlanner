package Cimindi.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SConcept;

public class check_dest_detail_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_dest_detail_NonTypesystemRule() {
  }
  public void applyRule(final SNode dest_detail, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    // ambil daftar semua aktivitas didalam dest_detail
    List<SNode> allActivities = SLinkOperations.getChildren(dest_detail, LINKS.activity$5Lg0);

    // lakukan pengecekan jika hanya jika ada lebih dari 1 aktv
    if (allActivities.size() > 1) {
      // loop u/setiap act (sebut saja act1)
      {
        Iterator<SNode> act1_it = ListSequence.fromList(allActivities).iterator();
        SNode act1_var;
        while (act1_it.hasNext()) {
          act1_var = act1_it.next();
          // inner loop u/ membandingkan act1 dgn semua act lain (sebut act2)
          {
            Iterator<SNode> act2_it = ListSequence.fromList(allActivities).iterator();
            SNode act2_var;
            while (act2_it.hasNext()) {
              act2_var = act2_it.next();
              // skip jika dibadingkan dg diri sendiri
              if (act1_var == act2_var) {
                continue;
              }

              // ambuk time range dari kedua act
              SNode tr1 = SLinkOperations.getTarget(act1_var, LINKS.time$8KDn);
              SNode tr2 = SLinkOperations.getTarget(act2_var, LINKS.time$8KDn);

              // lanhut hanya jika kedua time range dan start/end ny ada
              if (tr1 != null && tr2 != null && SLinkOperations.getTarget(tr1, LINKS.start$6ha8) != null && SLinkOperations.getTarget(tr1, LINKS.end$6mku) != null && SLinkOperations.getTarget(tr2, LINKS.start$6ha8) != null && SLinkOperations.getTarget(tr2, LINKS.end$6mku) != null) {
                // ambil nilai waktu dalam menit
                int start1 = (SPropertyOperations.getInteger(SLinkOperations.getTarget(tr1, LINKS.start$6ha8), PROPS.jam$67LZ) * 60) + SPropertyOperations.getInteger(SLinkOperations.getTarget(tr1, LINKS.start$6ha8), PROPS.menit$6810);
                int end1 = (SPropertyOperations.getInteger(SLinkOperations.getTarget(tr1, LINKS.end$6mku), PROPS.jam$67LZ) * 60) + SPropertyOperations.getInteger(SLinkOperations.getTarget(tr1, LINKS.end$6mku), PROPS.menit$6810);
                int start2 = (SPropertyOperations.getInteger(SLinkOperations.getTarget(tr2, LINKS.start$6ha8), PROPS.jam$67LZ) * 60) + SPropertyOperations.getInteger(SLinkOperations.getTarget(tr2, LINKS.start$6ha8), PROPS.menit$6810);
                int end2 = (SPropertyOperations.getInteger(SLinkOperations.getTarget(tr2, LINKS.end$6mku), PROPS.jam$67LZ) * 60) + SPropertyOperations.getInteger(SLinkOperations.getTarget(tr2, LINKS.end$6mku), PROPS.menit$6810);

                if (start1 < end2 && end1 > start2) {
                  {
                    final MessageTarget errorTarget = new NodeMessageTarget();
                    IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(act1_var, "jadwal kegiatan bentrok", "r:cdf7bab4-7410-48e6-9bd0-e2f83d1ac9b3(Cimindi.typesystem)", "75367278884359003", null, errorTarget);
                  }

                  break;
                }
              }
            }
          }
        }
      }
    }
  }
  public SAbstractConcept getApplicableConcept() {
    return CONCEPTS.dest_detail$Nn;
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return false;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink activity$5Lg0 = MetaAdapterFactory.getContainmentLink(0x68f6fd5bc2434b37L, 0x9ae039f662e054eeL, 0x5a354b9e51564b46L, 0x5a354b9e51564b48L, "activity");
    /*package*/ static final SContainmentLink time$8KDn = MetaAdapterFactory.getContainmentLink(0x68f6fd5bc2434b37L, 0x9ae039f662e054eeL, 0x5a354b9e51564aefL, 0x5a354b9e51564b8cL, "time");
    /*package*/ static final SContainmentLink start$6ha8 = MetaAdapterFactory.getContainmentLink(0x68f6fd5bc2434b37L, 0x9ae039f662e054eeL, 0x5a354b9e51564b64L, 0x5a354b9e51564b79L, "start");
    /*package*/ static final SContainmentLink end$6mku = MetaAdapterFactory.getContainmentLink(0x68f6fd5bc2434b37L, 0x9ae039f662e054eeL, 0x5a354b9e51564b64L, 0x5a354b9e51564b7aL, "end");
  }

  private static final class PROPS {
    /*package*/ static final SProperty menit$6810 = MetaAdapterFactory.getProperty(0x68f6fd5bc2434b37L, 0x9ae039f662e054eeL, 0x5a354b9e51564b65L, 0x5a354b9e51564b67L, "menit");
    /*package*/ static final SProperty jam$67LZ = MetaAdapterFactory.getProperty(0x68f6fd5bc2434b37L, 0x9ae039f662e054eeL, 0x5a354b9e51564b65L, 0x5a354b9e51564b66L, "jam");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept dest_detail$Nn = MetaAdapterFactory.getConcept(0x68f6fd5bc2434b37L, 0x9ae039f662e054eeL, 0x5a354b9e51564b46L, "Cimindi.structure.dest_detail");
  }
}
